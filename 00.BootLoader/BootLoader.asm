[ORG 0x00]
[BITS 16]

SECTION .text

jmp 0x07C0:START

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;OS관련 환경 설정
TOTALSECTORCOUNT:   dw  1024  ;부트 로더 제외 이미지 크기 1152 섹터(0x90000B)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	코드 	영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
	;화면 표시를 위한 설정
	mov ax, 0x07C0
	mov ds, ax
	mov ax, 0xB800
	mov es, ax

	;스택을 0~FFFF 영역에 65kd 크기로 설정
	mov ax, 0x0000
	mov ss, ax		;시작값 0  세그니까 ax활용
	mov sp, 0xFFFE	;top
	mov bp, 0xFFFE

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;화면 지우고 속석값은 녹색
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov si,	0

.SCREENCLEARLOOP:
	mov byte [ es: si ],0

	mov byte [ es: si + 1 ], 0x0F

	add si, 2                         ;2글자씩이니까 +2로

	cmp si, 80 * 25 * 2               ;si가 출력문자 수니 비교
	jl .SCREENCLEARLOOP               ;cmp에서 si가 더 작으면 루프 jmp low?

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  	;화면 상단에 시작 메시지 출력
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    push MESSAGE1				;출력할 꺼 스택에 넣고
    push 0						;y
    push 0						;x 좌표 설정했으면
    ; x, y, 문자
    call PRINTMESSAGE			;PRINTMESSAGE 함수 호출
    add sp, 6					;삽입 파라미터 제거

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  	;os 이미지 로딩 메시지 출력
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	push IMAGELOADINGMESSAGE	;출력 메시지 스택에 넣고
	push 1
	push 0
	call PRINTMESSAGE
	add sp, 6
	;위 참고

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 디스크에서 OS이미지를 로딩
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 디스크 읽기 전에 먼저 리셋
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESETDISK:
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;BIOS Reset Function 호출
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 서비스 번호 0, 드라이브 번호(0=플로피 디스크)
	mov ax, 0
	mov dl, 0
	int 0x13
	; 에러 발생시 처리
	jc HANDLEDISKERROR

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;디스크에서 섹터 읽음
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 디스코 내용 -> 메모리 복사 어드레스(ES:BX)=0x10000로
	mov si, 0x1000
	mov es, si
	mov bx, 0x0000
	;주소 하면 0ㅌ100000로

	mov di,word [TOTALSECTORCOUNT]

READDATA:                     ;디스크 읽는 코드 시작
  ;다 읽었나 보기
  cmp di,0
  je  READEND     ;0그러니까 끝까지 봤으면 끝으로
  sub di, 0x1	  ;읽었으니 감소
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;BIOS Read Function 호출
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  mov ah, 0x02                  ;BIOS 서비스 번호2
  mov al, 0x1                   ;읽은 섹터 수는 1 (1~128개나)
  mov ch, byte[ TRACKNUMBER ]   ;읽을 트랙 번호 설정 0~1023
  mov cl, byte[ SECTORNUMBER ]  ;읽을 섹터 번호 지정 1~18
  mov dh, byte[ HEADNUMBER ]   ;읽을 헤드 번호 설정 1~15
  ;트랙은 80개 섹터는 18개헤드는 2개
  mov dl, 0x00                  ;읽을 드라이버 번호 플로피 디스크로 설정
  int 0x13                      ;Disk I/O 서버스 인터럽드 바랭
  jc HANDLEDISKERROR            ;안되면 에러로 끝

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;복사할 어드레스, 트랙, 헤드, 섹터 어드레스 계산
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  add si, 0x0020      ;512(0x200) 다 봤으니 세그먼트 레지 값으로
  mov es, si          ;es도

  ;한 섹터 읽었으니 섹터 번호 증가 마지막 섹터(18)까지 읽었나 보기
  ;마지막 섹터가 아니면 다시

  mov al, byte [ SECTORNUMBER ]     ;섹터 번호를 AL 레지스터에 설정
  add al, 0x01                      ;섹터 번호 증가

  mov byte[ SECTORNUMBER ], al      ;증가한걸로 바꾸고
  cmp al, 19
  jl READDATA             ;19미만이면 위로 루프로

  ;마지막 섹터까지 읽었으면(섹터 번호가 19이면) 헤드를 토글(0->1, 1->0)
  ;섹터 번호를 1로 설정
  ;헤드는 0,1뿐이니까 한번 하고 다시하려면 토글을 사용
  xor byte [ HEADNUMBER ], 0x01     ;헤드 번호를 xor하여 토글
  mov byte [ SECTORNUMBER ], 0x01   ;섹터 번호를 다시 1로 설정

  ;헤드가 토글 됐으면 양쪽 다 읽은 거니까 이제 트랙 번호 1로
  cmp byte [ HEADNUMBER ], 0x00     ;헤드 번호 0x00과 비교
  jne READDATA                      ;0이 아니면 루프로

  ;트랙 1 증가시킨 후 다시 섹터 읽기로
  add byte [ TRACKNUMBER ], 0x01    ;트랙 번호를 1 증가
  jmp READDATA
READEND:

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;OS 이미지 완료 메시지 출력
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	push LOADINGCOMPLETEMESSAGE		;출력할 메시지의 어드레스를 스택에 삽입
	push 1
	push 20
	;x=20 y=1
	call PRINTMESSAGE
	add sp, 6

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;로딩할 가상 OS 이미지 실행
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	jmp 0x1000:0x0000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	함수 코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 디스크 에러 처리 함수
HANDLEDISKERROR:
	push DISKERRORMESSAGE
	push 1
	push 20
	call PRINTMESSAGE

	jmp $	;현위치에서 무한 루프

; 메시지 출력 함수
; x, y, 문자열
PRINTMESSAGE:
  push bp           ;BP를 이용해 파라미터 접근
  mov bp, sp

  push es
  push si
  push di
  push ax
  push cx
  push dx
  ;함수에서 의미로 사용할 것들

  mov ax, 0xB800    ;비디오 메모리 시작

  mov es, ax

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;X, Y 좌표로 비디오 메로리 어드레스 계산
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;Y
  mov ax, word [bp + 6]   ;파라미터 2 Y
  mov si, 160             ;한 라인이 2*80
  mul si                  ;ax레지와 si 곱해서 화면 y계산
  ;mul은 자동으로 ax랑 곱하는거
  mov di, ax

  ;X
  mov ax, word [bp + 4]   ;파라미터 1 X
  mov si, 2               ;한 문자의 크기 2
  mul si
  add di, ax              ;Y X를 더해 실제 비디오 메모리 어드레스 계산

  ;출력할꺼
  mov si, word [bp+8]     ;피라미터 3 출력 문자열 어드

.MESSAGELOOP:             ;메시지 출력 루프
  mov cl, byte [si]       ;가리키는 문자열 위치에서 한 문자를 cl로

	cmp cl, 0
	je .MESSAGEEND                    ;0이면 종료 이동해서 끝 이퀄

	mov byte [ es: di ], cl           ;0이 아니면 출력 cl=0이면 0을 넣는거니

	add si, 1
	add di, 2
	;가면서 끝나게 다음 글자로

	jmp .MESSAGELOOP


.MESSAGEEND:
  ;역순 출력
  pop dx
  pop cx
  pop ax
  pop di
  pop si
  pop es
  pop bp    ;BP복원
  ret       ;끝 다음 코드 위치 복귀

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 데이터 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 부트 로더 시작 메시지

MESSAGE1:  db 'MY OS Boot Loader Start~$#@!', 0 ;마지막을 0으로 해서 점프가능하게

DISKERRORMESSAGE:		db 'DISK Error!!!', 0
IMAGELOADINGMESSAGE:	db 'OS Image Loading.......', 0
LOADINGCOMPLETEMESSAGE:	db 'Complete~~', 0

; 디스크 읽기 관련 변수
SECTORNUMBER:       db  0x02  ;시작 섹터 번호 저정
HEADNUMBER:         db  0x00  ;헤드 번호 지정
TRACKNUMBER:        db  0x00  ;트랙

times 510 - ( $ - $$ )    db    0x00

db 0x55
db 0xAA
